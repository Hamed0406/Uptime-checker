
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    image: uptimechecker:prod
    restart: unless-stopped
    environment:
      # Core app settings
      ADDR: ":8080"
      LOG_DIR: "/var/log/uptime"

      # Auth (set your own secrets!)
      PUBLIC_API_KEYS: "${PUBLIC_API_KEYS}"
      ADMIN_API_KEYS:  "${ADMIN_API_KEYS}"

      # Probe + scheduler
      HTTP_TIMEOUT_MS: "${HTTP_TIMEOUT_MS:-5000}"
      RETRY_ATTEMPTS:  "${RETRY_ATTEMPTS:-3}"
      RETRY_BACKOFF_MS: "${RETRY_BACKOFF_MS:-300}"
      CHECK_INTERVAL_MS: "${CHECK_INTERVAL_MS:-60000}"
      MAX_CONCURRENT_CHECKS: "${MAX_CONCURRENT_CHECKS:-10}"

      # If you later re-enable Postgres in code, uncomment the next line:
      # DATABASE_URL: "${DATABASE_URL}"

    ports:
      - "8080:8080"
    volumes:
      - apilogs:/var/log/uptime
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:8080/healthz || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Uncomment this block *and* set DATABASE_URL above if/when you wire Postgres back in code.
  # db:
  #   image: postgres:16
  #   restart: unless-stopped
  #   environment:
  #     POSTGRES_USER:     ${POSTGRES_USER}
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  #     POSTGRES_DB:       ${POSTGRES_DB}
  #   volumes:
  #     - pgdata:/var/lib/postgresql/data
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
  #     interval: 5s
  #     timeout: 3s
  #     retries: 10
  #   ports:
  #     - "5432:5432"
  # api.depends_on:
  #   db:
  #     condition: service_healthy

volumes:
  apilogs:
  # pgdata:
