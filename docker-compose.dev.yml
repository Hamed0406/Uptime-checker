version: "3.9"

services:
  api:
    image: golang:1.22
    container_name: uptimechecker-api
    working_dir: /app
    ports:
      - "8080:8080"
    environment:
      # --- App config (safe defaults for dev) ---
      ADDR: ":8080"
      LOG_DIR: "/app/logs"
      PUBLIC_API_KEYS: "${PUBLIC_API_KEYS:-pub_test}"
      ADMIN_API_KEYS:  "${ADMIN_API_KEYS:-adm_test}"
      HTTP_TIMEOUT_MS: "${HTTP_TIMEOUT_MS:-5000}"
      RETRY_ATTEMPTS:  "${RETRY_ATTEMPTS:-3}"
      RETRY_BACKOFF_MS: "${RETRY_BACKOFF_MS:-300}"
      CHECK_INTERVAL_MS: "${CHECK_INTERVAL_MS:-60000}"        # 1 min
      MAX_CONCURRENT_CHECKS: "${MAX_CONCURRENT_CHECKS:-10}"
      # DATABASE_URL: "postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable"
      # ^ leave commented until you wire Postgres back into main.go
    volumes:
      - .:/app                # your source
      - gocache:/go/pkg/mod   # cache Go modules between runs
    # Build & run *inside* the container (no host toolchain/AV interference)
    command: >
      bash -lc "
        mkdir -p bin logs &&
        go mod download &&
        go build -o bin/api ./cmd/api &&
        ./bin/api
      "
    # If you later enable Postgres in code, you can add depends_on with the profile:
    # depends_on:
    #   db:
    #     condition: service_healthy

  db:
    image: postgres:16
    container_name: uptimechecker-db
    profiles: ["postgres"]     # only starts if you enable this profile
    environment:
      POSTGRES_USER:     ${POSTGRES_USER:-user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-pass}
      POSTGRES_DB:       ${POSTGRES_DB:-uptime}
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-user} -d ${POSTGRES_DB:-uptime}"]
      interval: 5s
      timeout: 3s
      retries: 10
    ports:
      - "5432:5432" # optional, handy for a local SQL client

volumes:
  gocache:
  pgdata:
